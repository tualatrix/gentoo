=== modified file 'Makefile.am'
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/configure.ac fast-user-switch-applet-2.24.0.new/configure.ac
--- fast-user-switch-applet-2.24.0/configure.ac	2009-04-09 20:43:27.118099936 +0100
+++ fast-user-switch-applet-2.24.0.new/configure.ac	2009-04-09 20:43:28.538103151 +0100
@@ -47,11 +47,13 @@
 PANEL_REQUIRED_VERSION=2.0.0
 GLADE_REQUIRED_VERSION=2.0.0
 GLIB_REQUIRED_VERSION=2.15.3
+DBUS_GLIB_REQUIRED_VERSION=0.76
 
 PKG_CHECK_MODULES(APPLET, gtk+-2.0 >= $GTK_REQUIRED_VERSION
 	     libpanelapplet-2.0 >= $PANEL_REQUIRED_VERSION
 	     libglade-2.0 >= $GLADE_REQUIRED_VERSION
 	     gio-2.0 >= $GLIB_REQUIRED_VERSION
+		 dbus-glib-1 >= $DBUS_GLIB_REQUIRED_VERSION
 	     polkit-gnome
 	     libgnomeui-2.0)
 AC_SUBST(APPLET_CFLAGS)
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/data/fast-user-switch-applet.schemas.in fast-user-switch-applet-2.24.0.new/data/fast-user-switch-applet.schemas.in
--- fast-user-switch-applet-2.24.0/data/fast-user-switch-applet.schemas.in	2009-04-09 20:43:26.926099906 +0100
+++ fast-user-switch-applet-2.24.0.new/data/fast-user-switch-applet.schemas.in	2009-04-09 20:43:28.542107953 +0100
@@ -86,6 +86,19 @@
       </locale>
     </schema>
     <schema>
+      <key>/schemas/apps/fast-user-switch-applet/show_presence_info</key>
+      <applyto>/apps/fast-user-switch-applet/show_presence_info</applyto>
+      <owner>fast-user-switch-applet</owner>
+      <type>bool</type>
+      <default>TRUE</default>
+      <locale name="C">
+	<short>Show Presence State</short>
+	<long>Whether to show the logged in user's presence information and allow
+	changing it in the applet.
+	</long>
+      </locale>
+    </schema>
+    <schema>
       <key>/schemas/apps/fast-user-switch-applet/show_session_commands</key>
       <applyto>/apps/fast-user-switch-applet/show_session_commands</applyto>
       <owner>fast-user-switch-applet</owner>
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/Makefile.am fast-user-switch-applet-2.24.0.new/Makefile.am
--- fast-user-switch-applet-2.24.0/Makefile.am	2008-09-22 14:54:53.000000000 +0100
+++ fast-user-switch-applet-2.24.0.new/Makefile.am	2009-04-09 20:43:28.542107953 +0100
@@ -38,8 +38,7 @@
 	intltool-extract		\
 	intltool-merge			\
 	intltool-update			\
-	./po/.intltool-merge-cache	\
-	gnome-doc-utils.make
+	./po/.intltool-merge-cache
 
 MAINTAINERCLEANFILES =	\
 	intltool-*.in	\
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/po/POTFILES.in fast-user-switch-applet-2.24.0.new/po/POTFILES.in
--- fast-user-switch-applet-2.24.0/po/POTFILES.in	2009-04-09 20:43:26.926099906 +0100
+++ fast-user-switch-applet-2.24.0.new/po/POTFILES.in	2009-04-09 20:43:28.542107953 +0100
@@ -13,3 +13,4 @@
 src/fusa-utils.c
 src/gdm-queue.c
 src/logout-dialog.c
+src/status-manager.c
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/applet.c fast-user-switch-applet-2.24.0.new/src/applet.c
--- fast-user-switch-applet-2.24.0/src/applet.c	2009-04-09 20:43:27.146103099 +0100
+++ fast-user-switch-applet-2.24.0.new/src/applet.c	2009-04-09 20:43:28.546101581 +0100
@@ -60,6 +60,7 @@
 #include <dbus/dbus-glib.h>
 
 #include "fusa-manager.h"
+#include "status-manager.h"
 #include "fusa-user-menu-item.h"
 #include "fusa-utils.h"
 #include "gdm-queue.h"
@@ -83,6 +84,7 @@
 #define SHOW_SCREEN_KEY	"/apps/fast-user-switch-applet/show_screen_item"
 #define SHOW_GUEST_KEY	"/apps/fast-user-switch-applet/show_guest_login"
 #define ACTIVE_ONLY_KEY	"/apps/fast-user-switch-applet/show_active_users_only"
+#define SHOW_PRESENCE_INFO "/apps/fast-user-switch-applet/show_presence_info"
 #define SHOW_SESSION_COMMANDS "/apps/fast-user-switch-applet/show_session_commands"
 
 #define LOCKDOWN_DIR    "/desktop/gnome/lockdown"
@@ -101,13 +103,13 @@
 
   GConfClient *client;
   FusaManager *manager;
+  FusaStatusManager *status_manager;
 
   GtkWidget *prefs;
   
   GtkWidget *menubar;
   GtkWidget *imglabel;
   GtkWidget *menu;
-  GtkWidget *separator_item;
   GtkWidget *login_screen_item;
   GtkWidget *login_window_item;
   GtkWidget *session_separator_item;
@@ -117,8 +119,14 @@
   GtkWidget *hibernate_item;
   GtkWidget *reboot_item;
   GtkWidget *shutdown_item;
+  GtkWidget *status_icon;
+
+  GtkWidget *status_items[FUSA_STATUS_MANAGER_STATUS_LAST];
+  GtkWidget *status_images[FUSA_STATUS_MANAGER_STATUS_LAST];
+  GtkWidget *status_separator_item;
 
   GtkWidget *guest_session_item;
+
   GSList *items;
 
   guint client_notify_applet_id;
@@ -208,6 +216,32 @@
 			 gpointer           data,
 			 const gchar       *cname);
 
+/* Panel Menu Callbacks -- Status */
+static void status_avail_cb (BonoboUIComponent *ui_container,
+			 gpointer           data,
+			 const gchar       *cname);
+static void status_away_cb (BonoboUIComponent *ui_container,
+			 gpointer           data,
+			 const gchar       *cname);
+static void status_dnd_cb (BonoboUIComponent *ui_container,
+			 gpointer           data,
+			 const gchar       *cname);
+static void status_offline_cb (BonoboUIComponent *ui_container,
+			 gpointer           data,
+			 const gchar       *cname);
+static void status_invisible_cb (BonoboUIComponent *ui_container,
+			 gpointer           data,
+			 const gchar       *cname);			 
+
+typedef void (*status_func_t)(BonoboUIComponent *, gpointer, const gchar *);
+status_func_t status_funcs[FUSA_STATUS_MANAGER_STATUS_LAST] = {
+	status_avail_cb,
+	status_away_cb,
+	status_dnd_cb,
+	status_invisible_cb,
+	status_offline_cb
+};
+
 /* FusaManager Callbacks */
 static void manager_user_added_cb       (FusaManager  *manager,
 					 FusaUser     *user,
@@ -227,6 +261,13 @@
 static void user_displays_changed_cb    (FusaUser *user,
 					 gpointer  data);
 
+/* FusaStatusManager Callbacks */
+static void status_updated_cb (FusaStatusManager * sm,
+                     gpointer  data);
+static void clients_updated_cb (FusaStatusManager * sm,
+                     gpointer  data);
+static void evaluate_status_visability (FusaAppletData * adata);
+
 /* GConfClient Callbacks */
 static void client_notify_applet_func (GConfClient *client,
 				       guint        cnxn_id,
@@ -332,6 +373,7 @@
 static void      make_label_bold              (GtkLabel       *label);
 static void      make_label_larger            (GtkLabel       *label);
 static void      make_label_small_italic      (GtkLabel       *label);
+static guint     find_menu_padding            (void);
 static void      fusa_applet_data_free        (FusaAppletData *adata);
 static void      dbus_namechange              (DBusGProxy * proxy,
                            const gchar * name,
@@ -363,6 +405,7 @@
  *  PanelApplet Callbacks  *
  * *********************** */
 
+
 static gboolean
 applet_fill_cb (PanelApplet *applet,
 	        const gchar *iid,
@@ -404,6 +447,7 @@
 				    NULL);
 
       g_type_init();
+	  dbus_g_thread_init();
 
       /* Add App specific icons to the search path */
       gtk_icon_theme_append_search_path(gtk_icon_theme_get_default(),
@@ -414,13 +458,24 @@
 			   "{\n"
 			     "GtkMenuBar::shadow-type = none\n"
 			     "GtkMenuBar::internal-padding = 0\n"
+			     "GtkWidget::focus-line-width = 0\n"
+			     "GtkWidget::focus-padding = 0\n"
+				 "GtkMenuItem::horizontal-padding = 0\n"
+			   "}\n"
+			   "style \"fast-user-switch-menuitem-style\"\n"
+			   "{\n"
+			     "GtkWidget::focus-line-width = 0\n"
+			     "GtkWidget::focus-padding = 0\n"
+				 "GtkMenuItem::horizontal-padding = 0\n"
 			   "}\n"
 			   "style \"fast-user-switch-applet-style\"\n"
 			   "{\n"
 			     "GtkWidget::focus-line-width = 0\n"
 			     "GtkWidget::focus-padding = 0\n"
+				 "GtkMenuItem::horizontal-padding = 0\n"
 			   "}\n"
 			   "widget \"*.fast-user-switch-menubar\" style \"fast-user-switch-menubar-style\"\n"
+			   "widget \"*.fast-user-switch-menuitem\" style \"fast-user-switch-menuitem-style\"\n"
 			   "widget \"*.fast-user-switch-applet\" style \"fast-user-switch-applet-style\"\n");
       gtk_window_set_default_icon_name ("stock_people");
       g_set_application_name (_("Fast User Switch Applet"));
@@ -431,6 +486,7 @@
 
   adata->client = gconf_client_get_default ();
   adata->manager = fusa_manager_ref_default ();
+  adata->status_manager = fusa_status_manager_ref_default ();
   adata->session_dialog = NULL;
 
   discover_pm_abilities(adata);
@@ -556,14 +612,18 @@
   g_signal_connect_after (adata->menubar, "expose-event",
 			  G_CALLBACK (menubar_expose_event_cb), adata);
   gtk_container_add (GTK_CONTAINER (applet), adata->menubar);
+  gtk_container_set_border_width (GTK_CONTAINER (adata->menubar), 0);
   gtk_widget_show (adata->menubar);
 
   menuitem = gtk_menu_item_new ();
+  gtk_widget_set_name (menuitem, "fast-user-switch-menuitem");
   gtk_menu_shell_append (GTK_MENU_SHELL (adata->menubar), menuitem);
+  gtk_widget_set_direction(menuitem, GTK_TEXT_DIR_RTL);
   gtk_widget_show (menuitem);
 
   hbox = gtk_hbox_new (FALSE, 0);
   gtk_container_add (GTK_CONTAINER (menuitem), hbox);
+  gtk_container_set_border_width(GTK_CONTAINER(hbox), 1);
   gtk_widget_show (hbox);
   
   value = panel_applet_gconf_get_string (applet, DISPLAY_KEY, NULL);
@@ -579,7 +639,7 @@
 	    g_signal_connect (user, "notify::display-name",
 			      G_CALLBACK (user_notify_display_name_cb),
 			      adata->imglabel);
-	  gtk_box_pack_start (GTK_BOX (hbox), adata->imglabel, TRUE, TRUE, 0);
+	  gtk_box_pack_start (GTK_BOX (hbox), adata->imglabel, TRUE, TRUE, 1);
 	  gtk_widget_show (adata->imglabel);
 	}
       else if (strcmp (value, "icon") == 0)
@@ -604,6 +664,20 @@
     }
   g_free (value);
 
+  const gchar * icon = fusa_status_manager_status_to_icon(fusa_status_manager_get_status(adata->status_manager));
+  adata->status_icon = gtk_image_new_from_icon_name(icon, GTK_ICON_SIZE_MENU);
+  GtkWidget * icon_align = gtk_alignment_new(0.0, 0.5, 1.0, 1.0);
+  gtk_alignment_set_padding(GTK_ALIGNMENT(icon_align), 0, 0, 2, find_menu_padding());
+  gtk_container_add(GTK_CONTAINER(icon_align), adata->status_icon);
+  gtk_box_pack_end (GTK_BOX (hbox), icon_align, TRUE, TRUE, 0);
+  gtk_widget_show(adata->status_icon);
+  gtk_widget_show(icon_align);
+
+  g_signal_connect (adata->status_manager, FUSA_STATUS_MANAGER_SIGNAL_STATUS_CHANGED,
+                       G_CALLBACK(status_updated_cb), adata);
+  g_signal_connect (adata->status_manager, FUSA_STATUS_MANAGER_SIGNAL_CLIENTS_STATUS_CHANGED,
+                       G_CALLBACK(clients_updated_cb), adata);
+
   adata->menu = gtk_menu_new ();
   gtk_menu_item_set_submenu (GTK_MENU_ITEM (menuitem), adata->menu);
   g_signal_connect (adata->menu, "style-set",
@@ -612,6 +686,63 @@
 		    G_CALLBACK (menu_expose_cb), adata);
   gtk_widget_show (adata->menu);
 
+  /* Add entry for status to Available */
+  int i = 0;
+  for (i = 0 ; i < FUSA_STATUS_MANAGER_STATUS_LAST; i++) {
+	  adata->status_items[i] = gtk_menu_item_new ( );
+
+	  GtkWidget * hbox = gtk_hbox_new(FALSE, 0);
+
+	  GtkWidget * label = gtk_label_new (fusa_status_manager_status_to_string(i));
+	  gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
+	  gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+	  gtk_box_pack_start(GTK_BOX(hbox), label, TRUE, TRUE, 0);
+	  gtk_widget_show(label);
+
+	  adata->status_images[i] = gtk_image_new_from_icon_name(fusa_status_manager_status_to_icon(i), GTK_ICON_SIZE_MENU);
+	  gtk_box_pack_start(GTK_BOX(hbox), adata->status_images[i], FALSE, TRUE, 0);
+	  gtk_widget_show(adata->status_images[i]);
+
+	  gtk_widget_show(hbox);
+	  gtk_container_add(GTK_CONTAINER(adata->status_items[i]), hbox);
+
+	  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu),
+				  adata->status_items[i]);
+	  g_signal_connect (adata->status_items[i], "destroy",
+				G_CALLBACK (menuitem_destroy_cb), adata);
+	  g_signal_connect (adata->status_items[i], "activate",
+				G_CALLBACK (status_funcs[i]), adata);
+  }
+
+  /* Add entry for lock screen */
+  adata->lock_screen_item = gtk_image_menu_item_new_with_label (_("Lock screen"));
+  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu),
+			  adata->lock_screen_item);
+  g_signal_connect (adata->lock_screen_item, "style-set",
+		    G_CALLBACK (menuitem_style_set_cb), adata);
+  g_signal_connect (adata->lock_screen_item, "destroy",
+		    G_CALLBACK (menuitem_destroy_cb), adata);
+  g_signal_connect (adata->lock_screen_item, "activate",
+		    G_CALLBACK (lock_screen_activate_cb), NULL);
+
+  /* Add a seperator */
+  adata->status_separator_item = gtk_separator_menu_item_new ();
+  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu), adata->status_separator_item);
+
+  /* Built all the status stuff now, let's decide if we want to show it. */
+  evaluate_status_visability(adata);
+  /* Add the 'other user' entry */
+  adata->login_screen_item = gtk_menu_item_new_with_label (_("Switch User..."));
+  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu),
+			  adata->login_screen_item);
+  g_signal_connect (adata->login_screen_item, "style-set",
+		    G_CALLBACK (menuitem_style_set_cb), adata);
+  g_signal_connect (adata->login_screen_item, "destroy",
+		    G_CALLBACK (menuitem_destroy_cb), adata);
+  g_signal_connect (adata->login_screen_item, "activate",
+		    G_CALLBACK (login_screen_activate_cb), adata);
+
+  /* Only show active users? */
   active_only = gconf_client_get_bool (adata->client, ACTIVE_ONLY_KEY, NULL);
 
   /* This next part populates the list with all the users we currently know
@@ -672,23 +803,6 @@
   g_signal_connect (adata->manager, "user-added",
 		    G_CALLBACK (manager_user_added_cb), adata);
 
-  /* Add a seperator */
-  adata->separator_item = gtk_separator_menu_item_new ();
-  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu), adata->separator_item);
-  adata->items = g_slist_prepend (adata->items, adata->separator_item);
-
-  /* Add the 'other user' entry */
-  adata->login_screen_item = gtk_menu_item_new_with_label (_("Switch User..."));
-  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu),
-			  adata->login_screen_item);
-  g_signal_connect (adata->login_screen_item, "style-set",
-		    G_CALLBACK (menuitem_style_set_cb), adata);
-  g_signal_connect (adata->login_screen_item, "destroy",
-		    G_CALLBACK (menuitem_destroy_cb), adata);
-  g_signal_connect (adata->login_screen_item, "activate",
-		    G_CALLBACK (login_screen_activate_cb), adata);
-  adata->items = g_slist_prepend (adata->items, adata->login_screen_item);
-
   /* Add an entry for a login window */
   adata->login_window_item = gtk_image_menu_item_new_with_label (_("Login Window"));
   gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (adata->login_window_item),
@@ -701,24 +815,11 @@
 		    G_CALLBACK (menuitem_destroy_cb), adata);
   g_signal_connect (adata->login_window_item, "activate",
 		    G_CALLBACK (login_window_activate_cb), adata);
-  adata->items = g_slist_prepend (adata->items, adata->login_window_item);
 
   /* Add a seperator */
   adata->session_separator_item = gtk_separator_menu_item_new ();
   gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu), adata->session_separator_item);
 
-  /* Add entry for lock screen */
-  adata->lock_screen_item = gtk_image_menu_item_new_with_label (_("Lock Screen"));
-  gtk_menu_shell_append (GTK_MENU_SHELL (adata->menu),
-			  adata->lock_screen_item);
-  g_signal_connect (adata->lock_screen_item, "style-set",
-		    G_CALLBACK (menuitem_style_set_cb), adata);
-  g_signal_connect (adata->lock_screen_item, "destroy",
-		    G_CALLBACK (menuitem_destroy_cb), adata);
-  g_signal_connect (adata->lock_screen_item, "activate",
-		    G_CALLBACK (lock_screen_activate_cb), NULL);
-
-
   /* Add entry for log off */
   sAppletAction = g_new0 (SelectorAppletAction, 3);
   sAppletAction[0].adata = adata;
@@ -831,14 +932,6 @@
 
   show_hide_guest (adata);
 
-  if (g_getenv ("LTSP_CLIENT") && (
-      GTK_WIDGET_VISIBLE (adata->login_screen_item) ||
-      GTK_WIDGET_VISIBLE (adata->login_window_item) ||
-      GTK_WIDGET_VISIBLE (adata->guest_session_item)))
-    gtk_widget_show (adata->separator_item);
-  else
-    gtk_widget_hide (adata->separator_item);
-
   key = panel_applet_gconf_get_full_key (applet, DISPLAY_KEY);
   if (key)
     {
@@ -1446,6 +1539,61 @@
   g_free (license_i18n);
 }
 
+static void
+status_avail_cb (BonoboUIComponent *ui_container,
+	  gpointer           data,
+	  const gchar       *cname)
+{
+	FusaAppletData * adata = data;
+
+	fusa_status_manager_set_status (adata->status_manager, FUSA_STATUS_MANAGER_STATUS_ONLINE, "");
+	return;
+}
+
+static void
+status_away_cb (BonoboUIComponent *ui_container,
+	  gpointer           data,
+	  const gchar       *cname)
+{
+	FusaAppletData * adata = data;
+
+	fusa_status_manager_set_status (adata->status_manager, FUSA_STATUS_MANAGER_STATUS_AWAY, "");
+	return;
+}
+
+static void
+status_dnd_cb (BonoboUIComponent *ui_container,
+	  gpointer           data,
+	  const gchar       *cname)
+{
+	FusaAppletData * adata = data;
+
+	fusa_status_manager_set_status (adata->status_manager, FUSA_STATUS_MANAGER_STATUS_DND, "");
+	return;
+}
+
+static void
+status_offline_cb (BonoboUIComponent *ui_container,
+	  gpointer           data,
+	  const gchar       *cname)
+{
+	FusaAppletData * adata = data;
+
+	fusa_status_manager_set_status (adata->status_manager, FUSA_STATUS_MANAGER_STATUS_OFFLINE, "");
+	return;
+}
+
+static void
+status_invisible_cb (BonoboUIComponent *ui_container,
+	  gpointer           data,
+	  const gchar       *cname)
+{
+	FusaAppletData * adata = data;
+
+	fusa_status_manager_set_status (adata->status_manager, FUSA_STATUS_MANAGER_STATUS_INVISIBLE, "");
+	return;
+}
+
 
 
 /* *********************** *
@@ -1626,6 +1774,50 @@
   sort_menu (adata);
 }
 
+static void
+status_updated_cb (FusaStatusManager * sm, gpointer data)
+{
+	FusaAppletData *adata = data;
+
+	const gchar * icon = fusa_status_manager_status_to_icon(fusa_status_manager_get_status(adata->status_manager));
+	gtk_image_set_from_icon_name(GTK_IMAGE(adata->status_icon), icon, GTK_ICON_SIZE_MENU);
+
+	return;
+}
+
+static void
+clients_updated_cb (FusaStatusManager * sm, gpointer data)
+{
+	FusaAppletData *adata = data;
+	evaluate_status_visability(adata);
+	sort_menu(adata);
+	return;
+}
+
+static void
+evaluate_status_visability (FusaAppletData * adata)
+{
+  guint i = 0;
+  gboolean show_presence = gconf_client_get_bool (adata->client, SHOW_PRESENCE_INFO, NULL);
+  guint num_clients = fusa_status_manager_num_clients(adata->status_manager);
+
+  if (show_presence && num_clients > 0) {
+	  const gchar * icon = fusa_status_manager_status_to_icon(fusa_status_manager_get_status(adata->status_manager));
+	  gtk_image_set_from_icon_name(GTK_IMAGE(adata->status_icon), icon, GTK_ICON_SIZE_MENU);
+	  gtk_widget_show(adata->status_icon);
+	  for (i = 0 ; i < FUSA_STATUS_MANAGER_STATUS_LAST; i++)
+		  gtk_widget_show(adata->status_items[i]);
+	  gtk_widget_show(adata->status_separator_item);
+  } else {
+	  gtk_image_set_from_icon_name(GTK_IMAGE(adata->status_icon), "gnome-logout", GTK_ICON_SIZE_MENU);
+	  for (i = 0 ; i < FUSA_STATUS_MANAGER_STATUS_LAST; i++)
+		  gtk_widget_hide(adata->status_items[i]);
+	  gtk_widget_hide(adata->status_separator_item);
+  }
+
+  return;
+}
+
 /* *********************** *
  *  GConfClient Callbacks  *
  * *********************** */
@@ -1763,12 +1955,6 @@
       reset_login_window_item (adata->login_window_item,
 			       gconf_value_get_bool (value), str);
       g_free (str);
-
-      if (GTK_WIDGET_VISIBLE (adata->login_screen_item) ||
-	  GTK_WIDGET_VISIBLE (adata->login_window_item))
-	gtk_widget_show (adata->separator_item);
-      else
-	gtk_widget_hide (adata->separator_item);
     }
   else if (strcmp (key, SUPPRESS_KEY) == 0)
     {
@@ -1850,14 +2036,10 @@
     {
 	  update_session_ui(adata);
     }
-
-  if (g_getenv ("LTSP_CLIENT") && (
-      GTK_WIDGET_VISIBLE (adata->login_screen_item) ||
-      GTK_WIDGET_VISIBLE (adata->login_window_item) ||
-      GTK_WIDGET_VISIBLE (adata->guest_session_item)))
-    gtk_widget_show (adata->separator_item);
-  else
-    gtk_widget_hide (adata->separator_item);
+  else if (strcmp (key, SHOW_PRESENCE_INFO) == 0)
+    {
+	  evaluate_status_visability(adata);
+    }
 
   sort_menu (adata);
 }
@@ -3080,7 +3262,6 @@
 			   gconstpointer b,
 			   gpointer      data)
 {
-  FusaAppletData *adata;
   gboolean a_is_user, b_is_user;
 
   a_is_user = FUSA_IS_USER_MENU_ITEM (a);
@@ -3096,19 +3277,6 @@
     return fusa_user_collate (fusa_user_menu_item_get_user ((FusaUserMenuItem *) a),
 			      fusa_user_menu_item_get_user ((FusaUserMenuItem *) b));
 
-  adata = data;
-  if (a == adata->separator_item)
-    return -1;
-
-  if (b == adata->separator_item)
-    return 1;
-
-  if (a == adata->login_screen_item)
-    return -1;
-
-  if (b == adata->login_screen_item)
-    return 1;
-
   return 0;
 }
 
@@ -3127,6 +3295,18 @@
 
   screen_height = gdk_screen_get_height (gtk_widget_get_screen (adata->menu));
 
+  guint offset = 1;
+  if (GTK_WIDGET_VISIBLE(adata->status_separator_item)) {
+    offset += FUSA_STATUS_MANAGER_STATUS_LAST;
+	/* status items and seperator */
+  }
+  if (GTK_WIDGET_VISIBLE(adata->lock_screen_item)) {
+    offset++;
+  }
+  if (GTK_WIDGET_VISIBLE(adata->login_screen_item)) {
+    offset++;
+  }
+
   n_items = 0;
   items = adata->items;
   while (items)
@@ -3162,8 +3342,10 @@
 	    fusa_user_menu_item_set_conflict(items->data, FALSE);
 	  }
 
+	  guint rrow = row + offset;
+
 	  gtk_menu_attach (GTK_MENU (adata->menu), items->data,
-			   column, column + 1, row, row + 1);
+			   column, column + 1, rrow, rrow + 1);
 	  row++;
 	  if (row > n_rows)
 	    {
@@ -3176,7 +3358,8 @@
            * have to set that explicitly.
            */
           gtk_menu_reorder_child (GTK_MENU (adata->menu),
-              items->data, count++);
+              items->data, count + offset);
+          count++;
 	}
 
 	  prev = items;
@@ -3386,18 +3569,60 @@
   pango_attr_list_unref (list);
 }
 
+static guint
+find_menu_padding (void) {
+  guint packing = 0;
+  guint hpadding = 0;
+
+  GtkWidget * menu = gtk_menu_new();
+  GtkWidget * mitem = gtk_menu_item_new();
+  gtk_container_add(GTK_CONTAINER(menu), mitem);
+
+  gtk_widget_realize(mitem);
+
+  gtk_widget_style_get (menu,
+                        "horizontal-padding", &hpadding,
+                        NULL);
+  packing += hpadding + 1;
+
+  gtk_widget_style_get (mitem,
+                        "horizontal-padding", &hpadding,
+                        NULL);
+  packing += hpadding + 1;
+
+  g_object_ref_sink(G_OBJECT(menu));
+
+  g_debug("Menu padding: %d", packing);
+  return packing;
+}
+
 static void
 fusa_applet_data_free (FusaAppletData *adata)
 {
   if (adata->prefs)
     gtk_widget_destroy (adata->prefs);
 
+  /* GConf Disconnects and unref */
   gconf_client_notify_remove (adata->client, adata->client_notify_applet_id);
   gconf_client_notify_remove (adata->client, adata->client_notify_global_id);
   gconf_client_notify_remove (adata->client, adata->client_notify_lockdown_id);
   gconf_client_remove_dir (adata->client, GLOBAL_DIR, NULL);
   g_object_unref (adata->client);
+
+  /* User manager */
   g_object_unref (adata->manager);
+
+  /* Status Manager */
+  gulong signal_id = g_signal_handler_find(adata->status_manager, G_SIGNAL_MATCH_DATA,
+                                           0, 0, NULL, NULL, adata);
+  while (signal_id != 0) {
+	  g_signal_handler_disconnect(adata->status_manager, signal_id);
+	  signal_id = g_signal_handler_find(adata->status_manager, G_SIGNAL_MATCH_DATA,
+									    0, 0, NULL, NULL, adata);
+  }
+  g_object_unref (adata->status_manager);
+
+  /* Tooltips */
   g_object_unref (tooltips);
 
   /* DBus Proxy */
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/gdm-queue.c fast-user-switch-applet-2.24.0.new/src/gdm-queue.c
--- fast-user-switch-applet-2.24.0/src/gdm-queue.c	2008-09-22 14:54:48.000000000 +0100
+++ fast-user-switch-applet-2.24.0.new/src/gdm-queue.c	2009-04-09 20:43:28.546101581 +0100
@@ -130,10 +130,13 @@
   new_request->callback = callback;
   new_request->data = data;
   
-  if (query==NULL)
+  if (query==NULL) {
     new_request->query = NULL;
-  else
+    g_debug("GDM Queueing Empty Query");
+  } else {
     new_request->query = g_strdup_vprintf (query, args);
+    g_debug("GDM Queueing Query: '%s'", new_request->query);
+  }
 
   va_end (args);
 
@@ -412,6 +415,7 @@
 /* This sends the command |command| to GDM. */
 static int gdm_send_command (const gchar *command)
 {
+  g_debug("GDM Send Command: '%s'", command);
   int ret;
   gchar *command_with_newline;
 #ifndef MSG_NOSIGNAL
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/Makefile.am fast-user-switch-applet-2.24.0.new/src/Makefile.am
--- fast-user-switch-applet-2.24.0/src/Makefile.am	2009-04-09 20:43:26.934099733 +0100
+++ fast-user-switch-applet-2.24.0.new/src/Makefile.am	2009-04-09 20:43:28.546101581 +0100
@@ -13,6 +13,8 @@
 	Makefile.in
 
 EXTRA_DIST =				\
+	status-manager-marshal.list	\
+	\
 	fusa-display.h			\
 	fusa-display-private.h		\
 	fusa-manager.h			\
@@ -23,9 +25,14 @@
 	fusa-utils.h			\
 	applet.h			\
 	gdm-queue.h			\
+	status-manager-marshal.h	\
+	status-manager.h		\
 	fade-and-grab.h			\
 	logout-dialog.h
 
+DISTCLEANFILES =			\
+	status-manager-marshal.c	\
+	status-manager-marshal.h
 
 # ################### #
 #  The Applet Itself  #
@@ -48,6 +55,8 @@
 	fusa-user-menu-item.c				\
 	fusa-utils.c					\
 	gdm-queue.c					\
+	status-manager-marshal.c			\
+	status-manager.c				\
 	fade-and-grab.c					\
 	logout-dialog.c
 
@@ -55,6 +64,9 @@
 	$(APPLET_LIBS)					\
 	$(X_LIBS)
 
+status-manager-marshal.c: status-manager-marshal.list
+	glib-genmarshal --body --prefix=status_manager_marshal $(srcdir)/status-manager-marshal.list > status-manager-marshal.c
+	glib-genmarshal --header --prefix=status_manager_marshal $(srcdir)/status-manager-marshal.list > status-manager-marshal.h
 
 # ##################### #
 #  Testing Application  #
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/status-manager.c fast-user-switch-applet-2.24.0.new/src/status-manager.c
--- fast-user-switch-applet-2.24.0/src/status-manager.c	1970-01-01 01:00:00.000000000 +0100
+++ fast-user-switch-applet-2.24.0.new/src/status-manager.c	2009-04-09 20:43:28.550099119 +0100
@@ -0,0 +1,738 @@
+/*
+ * Fast User Switch Applet: status-manager.c
+ * 
+ * Copyright (C) 2008 Canonical, Ltd.
+ * Authors:
+ *   Ted Gould <ted@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <config.h>
+
+#include <dbus/dbus-glib.h>
+
+#include <glib/gmessages.h>
+
+#include <glib-object.h>
+#include <glib/gstdio.h>
+#include <glib/gi18n.h>
+#include <gtk/gtkstock.h>
+
+#include "status-manager.h"
+#include "status-manager-marshal.h"
+
+#define FUSA_STATUS_MANAGER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), FUSA_TYPE_STATUS_MANAGER, FusaStatusManagerClass))
+#define FUSA_IS_STATUS_MANAGER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), FUSA_TYPE_STATUS_MANAGER))
+#define FUSA_STATUS_MANAGER_GET_CLASS(object) \
+  (G_TYPE_INSTANCE_GET_CLASS ((object), FUSA_TYPE_STATUS_MANAGER, FusaStatusManagerClass))
+
+/* Signals */
+enum {
+	STATUS_CHANGED,
+	CLIENTS_CHANGED,
+	LAST_SIGNAL
+};
+
+typedef enum {
+	MC_STATUS_UNSET,
+	MC_STATUS_OFFLINE,
+	MC_STATUS_AVAILABLE,
+	MC_STATUS_AWAY,
+	MC_STATUS_EXTENDED_AWAY,
+	MC_STATUS_HIDDEN,
+	MC_STATUS_DND,
+	MC_STATUS_INVISIBLE
+} mc_status_t;
+
+typedef enum {
+	PG_STATUS_UNKNOWN,
+	PG_STATUS_OFFLINE,
+	PG_STATUS_AVAILABLE,
+	PG_STATUS_UNAVAILABLE,
+	PG_STATUS_INVISIBLE,
+	PG_STATUS_AWAY,
+	PG_STATUS_EXTENDEND_AWAY,
+	PG_STATUS_MOBILE,
+	PG_STATUS_TUNE
+} pg_status_t;
+
+gchar * status_strings [FUSA_STATUS_MANAGER_STATUS_LAST] = {
+  /* FUSA_STATUS_MANAGER_STATUS_ONLINE,   */   N_("Available"),
+  /* FUSA_STATUS_MANAGER_STATUS_AWAY,     */   N_("Away"),
+  /* FUSA_STATUS_MANAGER_STATUS_DND       */   N_("Busy"),
+  /* FUSA_STATUS_MANAGER_STATUS_INVISIBLE,  */ N_("Invisible"),
+  /* FUSA_STATUS_MANAGER_STATUS_OFFLINE,  */   N_("Offline")
+};
+
+static const gchar * status_icons[FUSA_STATUS_MANAGER_STATUS_LAST] = {
+  /* FUSA_STATUS_MANAGER_STATUS_ONLINE, */   "user-online",
+  /* FUSA_STATUS_MANAGER_STATUS_AWAY, */     "user-away",
+  /* FUSA_STATUS_MANAGER_STATUS_DND, */      "user-busy",
+  /* FUSA_STATUS_MANAGER_STATUS_INVISIBLE */ "user-invisible",
+  /* FUSA_STATUS_MANAGER_STATUS_OFFLINE */   "user-offline"
+};
+
+FusaStatusManagerStatus mc_to_fusa_map[] = {
+	/* MC_STATUS_UNSET,         */  FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* MC_STATUS_OFFLINE,       */  FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* MC_STATUS_AVAILABLE,     */  FUSA_STATUS_MANAGER_STATUS_ONLINE,
+	/* MC_STATUS_AWAY,          */  FUSA_STATUS_MANAGER_STATUS_AWAY,
+	/* MC_STATUS_EXTENDED_AWAY, */  FUSA_STATUS_MANAGER_STATUS_AWAY,
+	/* MC_STATUS_HIDDEN,        */  FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* MC_STATUS_DND            */  FUSA_STATUS_MANAGER_STATUS_DND,
+	/* MC_STATUS_INVISIBLE      */  FUSA_STATUS_MANAGER_STATUS_INVISIBLE	
+};
+
+mc_status_t fusa_to_mc_map[] = {
+	/* FUSA_STATUS_MANAGER_STATUS_ONLINE,  */    MC_STATUS_AVAILABLE,
+	/* FUSA_STATUS_MANAGER_STATUS_AWAY,    */    MC_STATUS_AWAY,
+	/* FUSA_STATUS_MANAGER_STATUS_DND      */    MC_STATUS_DND,
+	/* FUSA_STATUS_MANAGER_STATUS_INVISIBLE  */  MC_STATUS_INVISIBLE,
+	/* FUSA_STATUS_MANAGER_STATUS_OFFLINE  */    MC_STATUS_OFFLINE
+};
+
+FusaStatusManagerStatus pg_to_fusa_map[] = {
+	/* PG_STATUS_UNKNOWN,        */   FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* PG_STATUS_OFFLINE,        */   FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* PG_STATUS_AVAILABLE,      */   FUSA_STATUS_MANAGER_STATUS_ONLINE,
+	/* PG_STATUS_UNAVAILABLE,    */   FUSA_STATUS_MANAGER_STATUS_DND,
+	/* PG_STATUS_INVISIBLE,      */   FUSA_STATUS_MANAGER_STATUS_INVISIBLE,
+	/* PG_STATUS_AWAY,           */   FUSA_STATUS_MANAGER_STATUS_AWAY,
+	/* PG_STATUS_EXTENDEND_AWAY, */   FUSA_STATUS_MANAGER_STATUS_AWAY,
+	/* PG_STATUS_MOBILE,         */   FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+	/* PG_STATUS_TUNE            */   FUSA_STATUS_MANAGER_STATUS_OFFLINE
+};
+
+pg_status_t fusa_to_pg_map[] = {
+	/* FUSA_STATUS_MANAGER_STATUS_ONLINE,  */  PG_STATUS_AVAILABLE,
+	/* FUSA_STATUS_MANAGER_STATUS_AWAY,    */  PG_STATUS_AWAY,
+	/* FUSA_STATUS_MANAGER_STATUS_DND      */  PG_STATUS_UNAVAILABLE,
+	/* FUSA_STATUS_MANAGER_STATUS_INVISIBLE*/  PG_STATUS_INVISIBLE,
+	/* FUSA_STATUS_MANAGER_STATUS_OFFLINE  */  PG_STATUS_OFFLINE
+};
+
+/* Class Structures */
+struct _FusaStatusManager
+{
+	GObject parent;
+
+	DBusGConnection * session_bus;
+
+	/* Mission Control */
+	DBusGProxy * mc_proxy;
+
+	/* Pidgin */
+	DBusGProxy * pg_proxy;
+
+	/* DBus events */
+	DBusGProxy * dbus_proxy;
+};
+
+typedef struct _FusaStatusManagerClass
+{
+	GObjectClass parent_class;
+
+	void (*status_changed) (FusaStatusManager* sm);
+	void (*clients_changed) (FusaStatusManager* sm);
+}
+FusaStatusManagerClass;
+
+guint  signals[LAST_SIGNAL] = { 0 };
+
+G_DEFINE_TYPE (FusaStatusManager, fusa_status_manager, G_TYPE_OBJECT);
+
+static void fusa_status_manager_finalize (GObject * obj);
+static void fusa_status_manager_dbus_namechange (DBusGProxy * proxy,
+                                     const gchar * name,
+                                     const gchar * prev,
+                                     const gchar * new,
+                                     FusaStatusManager * sm);
+
+/* Mission Control */
+static void mc_connect (FusaStatusManager * sm);
+static void mc_proxy_destroy (DBusGProxy * proxy, FusaStatusManager * sm);
+static void mc_changed_status (DBusGProxy * proxy, guint status, gchar * message, FusaStatusManager * sm);
+static void mc_expired (gpointer void_sm, GClosure * closure);
+static FusaStatusManagerStatus mc_get_status (FusaStatusManager * sm);
+static void mc_set_status (FusaStatusManager * sm, FusaStatusManagerStatus status, gchar * message);
+
+/* Pidgin */
+static void pg_connect (FusaStatusManager * sm);
+static void pg_proxy_destroy (DBusGProxy * proxy, FusaStatusManager * sm);
+static void pg_changed_status (DBusGProxy * proxy, gint savedstatus, gint notsure, FusaStatusManager * sm);
+static FusaStatusManagerStatus pg_get_status (FusaStatusManager * sm);
+static void pg_set_status (FusaStatusManager * sm, FusaStatusManagerStatus status, gchar * message);
+
+static void
+fusa_status_manager_class_init (FusaStatusManagerClass * class)
+{
+	GObjectClass * gobj;
+	gobj = G_OBJECT_CLASS(class);
+
+	gobj->finalize = fusa_status_manager_finalize;
+
+	signals[STATUS_CHANGED] = g_signal_new (FUSA_STATUS_MANAGER_SIGNAL_STATUS_CHANGED,
+	                               G_TYPE_FROM_CLASS(class),
+	                               G_SIGNAL_RUN_LAST,
+	                               G_STRUCT_OFFSET(FusaStatusManagerClass, status_changed),
+	                               NULL, NULL,
+	                               g_cclosure_marshal_VOID__VOID,
+	                               G_TYPE_NONE, 0);
+
+	signals[CLIENTS_CHANGED] = g_signal_new (FUSA_STATUS_MANAGER_SIGNAL_CLIENTS_STATUS_CHANGED,
+	                               G_TYPE_FROM_CLASS(class),
+	                               G_SIGNAL_RUN_LAST,
+	                               G_STRUCT_OFFSET(FusaStatusManagerClass, clients_changed),
+	                               NULL, NULL,
+	                               g_cclosure_marshal_VOID__VOID,
+	                               G_TYPE_NONE, 0);
+
+	return;
+}
+
+static void
+fusa_status_manager_init (FusaStatusManager * sm)
+{
+	GError *error = NULL;
+
+	sm->session_bus = dbus_g_bus_get(DBUS_BUS_SESSION, &error);
+	if (error != NULL) {
+		g_warning("Unable to connect to DBus Session Bus.  Status will not be available.  Reason: %s", error->message);
+		g_error_free(error);
+		return;
+	}
+
+	sm->dbus_proxy = dbus_g_proxy_new_for_name_owner (sm->session_bus,
+	                                                  DBUS_SERVICE_DBUS,
+	                                                  DBUS_PATH_DBUS,
+	                                                  DBUS_INTERFACE_DBUS,
+	                                                  &error);
+
+	if (error != NULL) {
+		g_warning("Unable to connect to DBus events: %s", error->message);
+		g_error_free(error);
+		return;
+	}
+
+	dbus_g_proxy_add_signal(sm->dbus_proxy, "NameOwnerChanged",
+	                        G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING,
+							G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal(sm->dbus_proxy, "NameOwnerChanged",
+	                        G_CALLBACK(fusa_status_manager_dbus_namechange),
+	                        sm, NULL);
+
+	/* Be doublely sure */
+	sm->mc_proxy = NULL;
+	sm->pg_proxy = NULL;
+
+	mc_connect(sm);
+	pg_connect(sm);
+
+	g_debug("Initialized status manager.");
+	return;
+}
+
+static void
+fusa_status_manager_finalize (GObject * obj)
+{
+	FusaStatusManager * sm;
+	sm = FUSA_STATUS_MANAGER(obj);
+
+	if (sm->session_bus != NULL) {
+		dbus_g_connection_unref(sm->session_bus);
+	}
+
+	if (G_OBJECT_CLASS(fusa_status_manager_parent_class)->finalize) {
+		(*G_OBJECT_CLASS(fusa_status_manager_parent_class)->finalize) (obj);
+	}
+
+	return;
+}
+
+FusaStatusManager * default_status_manager = NULL;
+
+FusaStatusManager *
+fusa_status_manager_ref_default (void)
+{
+	if (default_status_manager != NULL) {
+		g_object_ref(default_status_manager);
+	} else {
+		default_status_manager = g_object_new(FUSA_TYPE_STATUS_MANAGER, NULL);
+		g_object_add_weak_pointer(G_OBJECT(default_status_manager),
+		                          (gpointer *)&default_status_manager);
+	}
+
+	return default_status_manager;
+}
+
+static void
+fusa_status_manager_dbus_namechange (DBusGProxy * proxy,
+                                     const gchar * name,
+                                     const gchar * prev,
+                                     const gchar * new,
+                                     FusaStatusManager * sm)
+{
+	if (name != NULL && new != NULL) {
+		gboolean emit = FALSE;
+	    
+		if (strcmp(name, "im.pidgin.purple.PurpleService") == 0) {
+			pg_connect(sm);
+			emit = TRUE;
+		}
+		
+		if (strcmp(name, "org.freedesktop.Telepathy.MissionControl") == 0) {
+			mc_connect(sm);
+			emit = TRUE;
+		}
+
+		if (emit) {
+			g_signal_emit(sm, signals[CLIENTS_CHANGED], 0);
+		}
+	}
+	return;
+}
+
+FusaStatusManagerStatus
+fusa_status_manager_get_status (FusaStatusManager * manager)
+{
+	if (!FUSA_IS_STATUS_MANAGER(manager)) {
+		return FUSA_STATUS_MANAGER_STATUS_OFFLINE;
+	}
+
+	FusaStatusManagerStatus mcstatus = mc_get_status(manager);
+	FusaStatusManagerStatus pgstatus = pg_get_status(manager);
+
+	if (mcstatus < pgstatus) {
+		return mcstatus;
+	} else {
+		return pgstatus;
+	}
+}
+
+void
+fusa_status_manager_set_status (FusaStatusManager * manager, FusaStatusManagerStatus status, gchar * message)
+{
+	mc_set_status(manager, status, message);
+	pg_set_status(manager, status, message);
+	g_signal_emit(manager, signals[STATUS_CHANGED], 0);
+	return;
+}
+
+guint
+fusa_status_manager_num_clients (FusaStatusManager * manager)
+{
+	guint count = 0;
+
+	if (manager->mc_proxy != NULL) {
+		GError * error = NULL;
+		gboolean ret = FALSE;
+		guint mcstatus = MC_STATUS_UNSET;
+
+		ret = dbus_g_proxy_call(manager->mc_proxy,
+								"GetPresence", &error,
+								G_TYPE_INVALID,
+								G_TYPE_UINT, &mcstatus,
+								G_TYPE_INVALID);
+
+		/* If we can't get the  get call to work, let's not set */
+		if (!ret) {
+			if (error != NULL) {
+				g_error_free(error);
+			}
+		} else {
+			if (mcstatus != MC_STATUS_UNSET) {
+				count++;
+			}
+		}
+	}
+
+	if (manager->pg_proxy != NULL) {
+		count++;
+	}
+
+	return count;
+}
+
+const gchar *
+fusa_status_manager_status_to_icon (FusaStatusManagerStatus status)
+{
+	return status_icons[status];
+}
+
+const gchar *
+fusa_status_manager_status_to_string (FusaStatusManagerStatus status)
+{
+	return _(status_strings[status]);
+}
+
+/*********************
+ * Mission Control
+ * *******************/
+
+static void
+mc_connect (FusaStatusManager * sm)
+{
+	if (sm->mc_proxy != NULL) {
+		return; /* Already connected */
+	}
+
+	GError * error = NULL;
+
+	sm->mc_proxy = NULL;
+	sm->mc_proxy = dbus_g_proxy_new_for_name_owner(sm->session_bus,
+	                         "org.freedesktop.Telepathy.MissionControl",
+	                        "/org/freedesktop/Telepathy/MissionControl",
+	                         "org.freedesktop.Telepathy.MissionControl",
+							 &error
+	                                          );
+	if (sm->mc_proxy != NULL) {
+		g_object_add_weak_pointer (G_OBJECT(sm->mc_proxy), (gpointer *)&sm->mc_proxy);
+		g_signal_connect(G_OBJECT(sm->mc_proxy), "destroy",
+		                 G_CALLBACK(mc_proxy_destroy), sm);
+
+		dbus_g_object_register_marshaller(status_manager_marshal_VOID__UINT_STRING,
+		                            G_TYPE_NONE,
+		                            G_TYPE_UINT,
+		                            G_TYPE_STRING,
+		                            G_TYPE_INVALID);
+		dbus_g_proxy_add_signal    (sm->mc_proxy,
+		                            "PresenceChanged",
+		                            G_TYPE_UINT,
+		                            G_TYPE_STRING,
+		                            G_TYPE_INVALID);
+		dbus_g_proxy_connect_signal(sm->mc_proxy,
+		                            "PresenceChanged",
+		                            G_CALLBACK(mc_changed_status),
+		                            (void *)sm,
+		                            mc_expired);
+	} else {
+		g_warning("Unable to connect to Mission Control");
+		if (error != NULL) {
+			g_error_free(error);
+		}
+	}
+
+	return;
+}
+
+static void
+mc_proxy_destroy (DBusGProxy * proxy, FusaStatusManager * sm)
+{
+	g_debug("Signal: Mission Control proxy destroyed");
+	sm->mc_proxy = NULL;
+	g_signal_emit(sm, signals[CLIENTS_CHANGED], 0);
+	return;
+}
+
+static void
+mc_changed_status (DBusGProxy * proxy, guint status, gchar * message, FusaStatusManager * sm)
+{
+	g_signal_emit(sm, signals[STATUS_CHANGED], 0);
+}
+
+static void
+mc_expired (gpointer void_sm, GClosure * closure)
+{
+	FusaStatusManager * sm = FUSA_STATUS_MANAGER(void_sm);
+	mc_connect(sm);
+	return;
+}
+
+static FusaStatusManagerStatus
+mc_get_status (FusaStatusManager * sm)
+{
+	FusaStatusManagerStatus status = FUSA_STATUS_MANAGER_STATUS_OFFLINE;
+
+	if (sm->mc_proxy == NULL) {
+		return status;
+	}
+
+	guint mcstatus = MC_STATUS_UNSET;
+	gboolean ret = FALSE;
+	GError * error = NULL;
+
+	ret = dbus_g_proxy_call(sm->mc_proxy,
+	                        "GetPresence", &error,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_UINT, &mcstatus,
+	                        G_TYPE_INVALID);
+	if (!ret) {
+		if (error != NULL) {
+			g_warning("Unable to get presence data from Mission Control: %s", error->message);
+			g_error_free(error);
+		} else {
+			g_warning("Unable to get presence data from Mission Control");
+		}
+		return status;
+	}
+
+	if (mcstatus > MC_STATUS_UNSET && mcstatus <= MC_STATUS_DND) {
+		return mc_to_fusa_map[mcstatus];
+	} else {
+		return status;
+	}
+}
+
+static void
+mc_set_status (FusaStatusManager * sm, FusaStatusManagerStatus status, gchar * message)
+{
+	mc_status_t ms = fusa_to_mc_map[status];
+	guint mcstatus = MC_STATUS_UNSET;
+	gboolean ret = FALSE;
+	GError * error = NULL;
+
+	ret = dbus_g_proxy_call(sm->mc_proxy,
+	                        "GetPresence", &error,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_UINT, &mcstatus,
+	                        G_TYPE_INVALID);
+
+	/* If we can't get the  get call to work, let's not set */
+	if (!ret) {
+		if (error != NULL) {
+			g_error_free(error);
+		}
+		return;
+	}
+	
+	/* If the get call doesn't return a status, that means that there
+	   are no clients connected.  We don't want to connect them by telling
+	   MC that we're going online -- we'd like to be more passive than that. */
+	if (mcstatus == MC_STATUS_UNSET) {
+		return;
+	}
+
+	ret = dbus_g_proxy_call(sm->mc_proxy,
+	                        "SetPresence", &error,
+	                        G_TYPE_UINT, ms,
+	                        G_TYPE_STRING, "",
+	                        G_TYPE_INVALID,
+	                        G_TYPE_INVALID);
+
+	if (!ret) {
+		if (error != NULL) {
+			g_warning("Unable to set Mission Control Presence: %s", error->message);
+			g_error_free(error);
+		} else {
+			g_warning("Unable to set Mission Control Presence");
+		}
+		return;
+	}
+
+	return;
+}
+
+/*********************
+ * Pidgin
+ * *******************/
+
+static void
+pg_connect (FusaStatusManager * sm)
+{
+	if (sm->pg_proxy != NULL) {
+		return; /* Already connected */
+	}
+
+	g_debug("Connecting to Pidgin");
+	GError * error = NULL;
+	sm->pg_proxy = NULL;
+	sm->pg_proxy = dbus_g_proxy_new_for_name_owner(sm->session_bus,
+	                         "im.pidgin.purple.PurpleService",
+	                        "/im/pidgin/purple/PurpleObject",
+	                         "im.pidgin.purple.PurpleInterface",
+							 &error
+	                                          );
+	if (sm->pg_proxy != NULL) {
+		g_object_add_weak_pointer (G_OBJECT(sm->pg_proxy), (gpointer *)&sm->pg_proxy);
+		g_signal_connect(G_OBJECT(sm->pg_proxy), "destroy",
+		                 G_CALLBACK(pg_proxy_destroy), sm);
+
+		g_debug("Adding Pidgin Signals");
+		dbus_g_object_register_marshaller(status_manager_marshal_VOID__INT_INT,
+		                            G_TYPE_NONE,
+		                            G_TYPE_INT,
+		                            G_TYPE_INT,
+		                            G_TYPE_INVALID);
+		dbus_g_proxy_add_signal    (sm->pg_proxy,
+		                            "SavedstatusChanged",
+		                            G_TYPE_INT,
+		                            G_TYPE_INT,
+		                            G_TYPE_INVALID);
+		dbus_g_proxy_connect_signal(sm->pg_proxy,
+		                            "SavedstatusChanged",
+		                            G_CALLBACK(pg_changed_status),
+		                            (void *)sm,
+		                            NULL);
+	} else {
+		g_debug("Unable to connect to Pidgin");
+		if (error != NULL) {
+			g_error_free(error);
+		}
+	}
+
+	return;
+}
+
+static void
+pg_proxy_destroy (DBusGProxy * proxy, FusaStatusManager * sm)
+{
+	g_debug("Signal: Pidgin proxy destroyed");
+	sm->pg_proxy = NULL;
+	g_signal_emit(sm, signals[CLIENTS_CHANGED], 0);
+	return;
+}
+
+static void
+pg_changed_status (DBusGProxy * proxy, gint savedstatus, gint notsure, FusaStatusManager * sm)
+{
+	g_debug("Signal: Pidgin status changed");
+	g_signal_emit(sm, signals[STATUS_CHANGED], 0);
+	return;
+}
+
+static FusaStatusManagerStatus
+pg_get_status (FusaStatusManager * sm)
+{
+	g_debug("Pidgin Get Status");
+	FusaStatusManagerStatus status = FUSA_STATUS_MANAGER_STATUS_OFFLINE;
+
+	if (sm->pg_proxy == NULL) {
+		return status;
+	}
+
+	gint saved_status = PG_STATUS_UNKNOWN;
+	gboolean ret = FALSE;
+	GError * error = NULL;
+
+	g_debug("Pidgin getting current status");
+	ret = dbus_g_proxy_call(sm->pg_proxy,
+	                        "PurpleSavedstatusGetCurrent", &error,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_INT, &saved_status,
+	                        G_TYPE_INVALID);
+
+	if (!ret) {
+		if (error != NULL) {
+			g_warning("Unable to get Pidgin Status: %s", error->message);
+			g_error_free(error);
+		} else {
+			g_warning("Unable to get Pidgin Status");
+		}
+		return status;
+	}
+
+	gint status_code = 0;
+
+	g_debug("Pidgin figuring out type for %d", saved_status);
+	ret = dbus_g_proxy_call(sm->pg_proxy,
+	                        "PurpleSavedstatusGetType", &error,
+	                        G_TYPE_INT, saved_status,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_INT, &status_code,
+	                        G_TYPE_INVALID);
+
+	if (!ret) {
+		if (error != NULL) {
+			g_warning("Unable to determine Pidgin status type for saved status %d: %s", saved_status, error->message);
+			g_error_free(error);
+		} else {
+			g_warning("Unable to determine Pidgin status type for saved status %d", saved_status);
+		}
+		return status;
+	}
+
+	g_debug("Pidgin final status type: %d", saved_status);
+	if (status_code > PG_STATUS_UNKNOWN && status_code <= PG_STATUS_TUNE) {
+		return pg_to_fusa_map[status_code];
+	} else {
+		return status;
+	}
+}
+
+static void
+pg_set_status (FusaStatusManager * sm, FusaStatusManagerStatus status, gchar * message)
+{
+	g_debug("Pidgin set status to %d", status);
+	if (sm->pg_proxy == NULL) {
+		return;
+	}
+
+	gint status_val = 0;
+	gboolean ret = FALSE;
+	GError * error = NULL;
+
+	ret = dbus_g_proxy_call(sm->pg_proxy,
+	                        "PurpleSavedstatusFindTransientByTypeAndMessage", &error,
+							G_TYPE_INT, fusa_to_pg_map[status],
+							G_TYPE_STRING, message,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_INT, &status_val,
+	                        G_TYPE_INVALID);
+
+	if (!ret) {
+		if (error != NULL) {
+			g_error_free(error);
+		}
+		error = NULL;
+		status_val = 0;
+		g_debug("No Pidgin saved status to apply");
+	}
+
+	if (status_val == 0) {
+		ret = dbus_g_proxy_call(sm->pg_proxy,
+								"PurpleSavedstatusNew", &error,
+								G_TYPE_STRING, message,
+								G_TYPE_INT, fusa_to_pg_map[status],
+								G_TYPE_INVALID,
+								G_TYPE_INT, &status_val,
+								G_TYPE_INVALID);
+
+		if (!ret) {
+			status_val = 0;
+			if (error != NULL) {
+				g_warning("Unable to create Pidgin status for %d: %s", status, error->message);
+				g_error_free(error);
+			} else {
+				g_warning("Unable to create Pidgin status for %d", status);
+			}
+			error = NULL;
+		}
+	}
+
+	if (status_val == 0) {
+		return;
+	}
+
+	ret = dbus_g_proxy_call(sm->pg_proxy,
+	                        "PurpleSavedstatusActivate", &error,
+	                        G_TYPE_INT, status_val,
+	                        G_TYPE_INVALID,
+	                        G_TYPE_INVALID);
+
+	if (!ret) {
+		if (error != NULL) {
+			g_warning("Pidgin unable to change to status: %s", error->message);
+			g_error_free(error);
+		} else {
+			g_warning("Pidgin unable to change to status");
+		}
+		error = NULL;
+	}
+
+	return;
+}
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/status-manager.h fast-user-switch-applet-2.24.0.new/src/status-manager.h
--- fast-user-switch-applet-2.24.0/src/status-manager.h	1970-01-01 01:00:00.000000000 +0100
+++ fast-user-switch-applet-2.24.0.new/src/status-manager.h	2009-04-09 20:43:28.550099119 +0100
@@ -0,0 +1,76 @@
+/* 
+ * Fast User Switch Applet: status-manager.h
+ * 
+ * Copyright (C) 2008 Canonical, Ltd.
+ *
+ * Authors:
+ * 		Ted Gould <ted@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Singleton object to manage connection to IM clients with their
+ * interaction/configs.
+ */
+
+#ifndef __STATUS_MANAGER_H__
+#define __STATUS_MANAGER_H__ 1
+
+G_BEGIN_DECLS
+
+#define FUSA_TYPE_STATUS_MANAGER \
+  (fusa_status_manager_get_type ())
+#define FUSA_STATUS_MANAGER(object) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((object), FUSA_TYPE_STATUS_MANAGER, FusaStatusManager))
+#define FUSA_IS_STATUS_MANAGER(object) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((object), FUSA_TYPE_STATUS_MANAGER))
+
+#define FUSA_STATUS_MANAGER_SIGNAL_STATUS_CHANGED \
+  "status-changed"
+#define FUSA_STATUS_MANAGER_SIGNAL_CLIENTS_STATUS_CHANGED \
+  "client-status-changed"
+
+typedef enum
+{
+  FUSA_STATUS_MANAGER_STATUS_ONLINE,
+  FUSA_STATUS_MANAGER_STATUS_AWAY,
+  FUSA_STATUS_MANAGER_STATUS_DND,
+  FUSA_STATUS_MANAGER_STATUS_INVISIBLE,
+  FUSA_STATUS_MANAGER_STATUS_OFFLINE,
+  /* Leave as last */
+  FUSA_STATUS_MANAGER_STATUS_LAST
+}
+FusaStatusManagerStatus;
+
+typedef struct _FusaStatusManager FusaStatusManager;
+
+GType        fusa_status_manager_get_type              (void) G_GNUC_CONST;
+
+FusaStatusManager *fusa_status_manager_ref_default           (void);
+
+
+FusaStatusManagerStatus fusa_status_manager_get_status  (FusaStatusManager * manager);
+GSList *                fusa_status_manager_get_status_messages (FusaStatusManager * manager);
+void                    fusa_status_manager_set_status  (FusaStatusManager * manager,
+                                                         FusaStatusManagerStatus status,
+                                                         gchar * message);
+guint                   fusa_status_manager_num_clients (FusaStatusManager * manager);
+const gchar *           fusa_status_manager_status_to_icon (FusaStatusManagerStatus status);
+const gchar *           fusa_status_manager_status_to_string (FusaStatusManagerStatus status);
+
+G_END_DECLS
+
+#endif /* !__FUSA_STATUS_MANAGER_H__ */
diff -Nur -x '*.orig' -x '*~' fast-user-switch-applet-2.24.0/src/status-manager-marshal.list fast-user-switch-applet-2.24.0.new/src/status-manager-marshal.list
--- fast-user-switch-applet-2.24.0/src/status-manager-marshal.list	1970-01-01 01:00:00.000000000 +0100
+++ fast-user-switch-applet-2.24.0.new/src/status-manager-marshal.list	2009-04-09 20:43:28.550099119 +0100
@@ -0,0 +1,6 @@
+# Pidgin Interface (im.pidgin)
+# Signal: SavedstatusChanged
+VOID:INT,INT
+# Mission Control Interface (org.freedesktop.Telepathy.MissionControl)
+# Signal: PresenceChanged
+VOID:UINT,STRING
